[
  {
    "id": "agent-knowledge-base/index",
    "title": "INDEX",
    "content": "Agent Knowledge Base - Reference Index Quick navigation for all reference documents. These resources provide high-signal technical primitives for autonomous agents. ---  Memory & State Primitives Core tools for persistent, graph-based memory and industrialized agent coordination. - Introducing Beads - Git-backed memory system solving \"context rot\" and the \"Dementia Problem\" âš ï¸ Manual access required (Medium blocked) - Welcome to Gas Town - MEOW stack orchestration framework with role-based agent topology âš ï¸ Manual access required (Medium blocked) - Beads Repository - Official bd CLI implementation with  for agents - Beads Viewer (bv) - Graph analytics TUI with PageRank and critical path analysis ---  Autonomous Loops (Ralph Wiggum Technique) Patterns for \"deterministically bad\" loops that brute-force correctness via iteration. - The Original Ralph Wiggum Technique - Core while-loop primitive and economic validation ($50k project for $297 in API costs) - RepoMirror Experiment - Empirica",
    "url": "/agent-knowledge-base/index",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/claude-code-essentials",
    "title": "claude-code-essentials",
    "content": "Claude Code Essentials for Agents > Quick reference for key Claude Code concepts. For complete documentation, see .  Skills What: Markdown files that teach Claude how to do specific tasks How they work: 1. Discovery: At startup, Claude loads only name + description (fast) 2. Activation: When request matches description, Claude asks to use Skill 3. Execution: Full  loaded, instructions followed Structure: Locations: - Personal:  (all projects) - Project:  (team-shared) - Plugin: Provided by installed plugins Key insight: Skills are model-invoked - Claude decides which to use based on description matching. Write descriptions with keywords users naturally say. Full docs: ,  ---  Hooks What: Event-driven automation that runs commands or LLM prompts at specific points in Claude's workflow Event types: - : After user sends message, before Claude processes - : Before Claude uses a tool (can block with non-zero exit) - : When tool requires permission (can auto-approve) - : After tool completes",
    "url": "/agent-knowledge-base/claude-code-essentials",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/context/agentsmd-spec",
    "title": "agentsmd-spec",
    "content": "AGENTS.md Specification Summary  Core Definition AGENTS.md is a vendor-neutral markdown format designed to guide AI coding agents. As stated on the official site: \"A simple, open format for guiding coding agents, used by over 60k open-source projects.\"  Schema & Structure Rather than enforcing a rigid schema, AGENTS.md intentionally remains flexible. The specification explicitly states: \"AGENTS.md is just standard Markdown. Use any headings you like; the agent simply parses the text you provide.\" Common sections include: - Project overview - Build and test commands - Code style guidelines - Testing instructions - Security considerations - PR/commit message guidelines  Agent Personas & Boundaries The format doesn't define specific agent personas but rather creates \"a dedicated, predictable place to provide the context and instructions\" for any AI coding agent to operate effectively. Key boundary principle: \"The closest AGENTS.md to the edited file wins; explicit user chat prompts overri",
    "url": "/agent-knowledge-base/context/agentsmd-spec",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/context/anthropic-context-engineering",
    "title": "anthropic-context-engineering",
    "content": "Context Engineering for AI Agents: Key Concepts  Context Engineering vs. Prompt Engineering Prompt engineering focuses on crafting effective LLM instructions, particularly system prompts. Context engineering represents the broader evolutionâ€”managing the entire token composition during inference, including system instructions, tools, external data, and message history across multiple turns. As Anthropic explains: \"context engineering is iterative and the curation phase happens each time we decide what to pass to the model.\"  Context Rot Phenomenon LLMs experience performance degradation as context length increases. Research shows that \"as the number of tokens in the context window increases, the model's ability to accurately recall information from that context decreases.\" This stems from transformer architecture's nÂ² pairwise token relationships. Models trained on shorter sequences have fewer specialized parameters for long-range dependencies, creating a performance gradient rather tha",
    "url": "/agent-knowledge-base/context/anthropic-context-engineering",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/context/github-par",
    "title": "github-par",
    "content": "Par: Parallel Worktree & Session Manager par is a CLI tool that streamlines concurrent development workflows by combining Git worktrees with tmux session management. It enables developersâ€”particularly those working with AI coding assistantsâ€”to manage multiple isolated development environments globally.  Core Functionality The tool creates isolated workspaces where each session gets its own directory, Git branch, and tmux session. As the documentation states, it's designed to solve a fundamental problem: \"traditional Git branch switching is not ideal for handling multiple concurrent workstreams on the same repository.\"  Key Capabilities - Global session management: Create, list, and access development contexts from anywhere on your system - Multi-repository workspaces: Coordinate changes across multiple repositories with synchronized branch naming - Remote command execution: Send commands to specific sessions or broadcast to all contexts simultaneously - IDE integration: Auto-generates ",
    "url": "/agent-knowledge-base/context/github-par",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/context/google-adk",
    "title": "google-adk",
    "content": "Google ADK: Core Architectural Concepts  1. Compiled View Concept Google's ADK treats context as a derived representation rather than mutable storage. The framework separates concerns into layers: - Sources: Sessions, memory, and artifacts contain full structured state - Compiler pipeline: Flows and processors transform that state through ordered passes - Output: Working context is the ephemeral projection sent to the LLM As the article states: \"Context is a compiled view over a richer stateful system.\" This shift reframes context management from prompt engineering into systems architecture, where you ask questions about intermediate representations, compaction points, and transformation observability.  2. Handle Pattern for Artifacts Rather than embedding large data (5MB CSVs, PDFs, JSON responses) directly in prompts, ADK uses indirect references: - Large objects live in an  as named, versioned resources - Agents see lightweight summaries by default - The  allows agents to fetch full",
    "url": "/agent-knowledge-base/context/google-adk",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/context/humanlayer-claude-md",
    "title": "humanlayer-claude-md",
    "content": "CLAUDE.md Specification Summary  Recommended Length The article specifies that CLAUDE.md files should be under 300 lines, with shorter being preferable. HumanLayer's own root file is less than 60 lines.  What to Include The file should cover three essential areas: 1. WHAT â€“ Technical stack and project structure. \"Give Claude a map of the codebase,\" particularly important for monorepos where you clarify apps, shared packages, and their purposes. 2. WHY â€“ Project purpose and the function of different components so Claude understands the system's intent. 3. HOW â€“ Practical workflow information: build tools (e.g.,  vs ), test execution, verification methods, and compilation steps needed for meaningful work.  What to Avoid The article explicitly recommends against: - Code style guidelines â€“ \"Never send an LLM to do a linter's job.\" Use deterministic linters instead. - Excessive instructions â€“ Frontier LLMs can reliably follow \"~150-200 instructions.\" Since Claude Code's system prompt alread",
    "url": "/agent-knowledge-base/context/humanlayer-claude-md",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/coordination/github-mcp-agent-mail",
    "title": "github-mcp-agent-mail",
    "content": "MCP Agent Mail > \"It's like gmail for your coding agents!\"  Overview MCP Agent Mail is a mail-like coordination layer for coding agents, exposed as an HTTP-only FastMCP server. It gives agents memorable identities, an inbox/outbox, searchable message history, and voluntary file reservation \"leases\" to avoid stepping on each other. Think of it as asynchronous email + directory + change-intent signaling for your agents, backed by Git (for human-auditable artifacts) and SQLite (for indexing and queries).  Why This Exists Modern projects often run multiple coding agents at once (backend, frontend, scripts, infra). Without a shared coordination fabric, agents: - Overwrite each other's edits or panic on unexpected diffs - Miss critical context from parallel workstreams - Require humans to \"liaison\" messages across tools and teams This project provides a lightweight, interoperable layer so agents can: - Register a temporary-but-persistent identity (e.g., GreenCastle) - Send/receive GitHub-Fla",
    "url": "/agent-knowledge-base/coordination/github-mcp-agent-mail",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/coordination/github-mcp-inspector",
    "title": "github-mcp-inspector",
    "content": "MCP Inspector Summary  Purpose MCP Inspector serves as a comprehensive developer tool for testing and debugging Model Context Protocol servers. According to the documentation, \"The MCP inspector is a developer tool for testing and debugging MCP servers.\"  Core Architecture The tool consists of two integrated components: 1. MCP Inspector Client (MCPI): A React-based web interface enabling interactive server testing 2. MCP Proxy (MCPP): A Node.js bridge connecting the UI to MCP servers via stdio, SSE, or streamable-HTTP transports  Key Capabilities Resource & Prompt Verification: The inspector allows developers to explore and validate server resources through an interactive browser interface with hierarchical navigation and JSON visualization. Users can also test prompt capabilities programmatically. Usage Examples: - List available tools:  - Call specific tools with parameters for testing functionality - Connect to remote servers via SSE or HTTP transports - Export server configurations",
    "url": "/agent-knowledge-base/coordination/github-mcp-inspector",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/loops/anthropic-ralph-plugin",
    "title": "anthropic-ralph-plugin",
    "content": "Ralph Wiggum Plugin Summary  Overview The Ralph Wiggum plugin implements an iterative AI development loop technique in Claude Code. Named after the persistent Simpsons character, it enables autonomous, self-referential improvement cycles where Claude refines its work iteratively until completion.  Core Architecture: Stop Hook Key Mechanism: A Stop Hook () intercepts Claude's exit attempts and creates a self-referential feedback loop: Why it works: The prompt never changes, but previous work persists in files. Each iteration, Claude sees modified files and git history, enabling autonomous self-improvement by reading its own past work.  Plugin Configuration Directory Structure: -  - Plugin metadata -  - Command implementations -  - Stop hook logic -  - Supporting utilities Commands:   Options: -  - Stop after N iterations (default: unlimited) -  - Phrase that signals completion (exact string matching)   Cancels the active loop immediately.  Verification & Forced Iteration Self-Correction",
    "url": "/agent-knowledge-base/loops/anthropic-ralph-plugin",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/loops/ghuntley-ralph",
    "title": "ghuntley-ralph",
    "content": "The Ralph Technique: Core Concepts & Economic Model  Core Primitive Ralph is fundamentally a simple bash loop that automates code generation: According to the article, \"Ralph is a technique\" that operates by continuously feeding prompts to an LLM without tool-call limitations, iterating until objectives are met.  Key Characteristics Deterministic Defects: The author notes that \"the technique is deterministically bad in an undeterministic world.\" This paradox means Ralph's failures are predictable and addressable through prompt refinement rather than tool selection. Skill-Based Operation: Ralph requires what the author describes as iterative tuningâ€”like adjusting an instrument. When Ralph produces errors, the operator modifies prompts (analogous to adding guidance signs) rather than blaming the underlying tool.  Economic Validation The most striking data point shared comes from an engineer who reportedly delivered a $50,000 contract project for approximately $297 in tool costs. This rep",
    "url": "/agent-knowledge-base/loops/ghuntley-ralph",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/loops/github-ralph-claude",
    "title": "github-ralph-claude",
    "content": "Ralph for Claude Code: Enterprise Implementation Summary  Overview Ralph is a bash-based automation framework enabling continuous autonomous development cycles with Claude Code. It implements Geoffrey Huntley's technique to execute iterative improvements while maintaining safety guardrails.  Core Safety Architecture Circuit Breaker Pattern The system monitors three failure indicators: \"3 loops with no progress, 5 loops with repeated errors, or output declining >70%.\" When triggered, the circuit opens automatically to prevent runaway execution. Rate Limiting Ralph enforces hourly API call quotas (configurable, default 100 calls/hour) with countdown timers. It detects Claude's 5-hour usage ceiling and prompts for wait-or-exit decisions rather than entering retry loops. Stagnation Detection The framework tracks consecutive test-focused iterations (threshold: 3 loops) and repetitive \"done\" signals (threshold: 2 occurrences). Multi-line error matching distinguishes genuine failures from fal",
    "url": "/agent-knowledge-base/loops/github-ralph-claude",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/loops/github-repomirror",
    "title": "github-repomirror",
    "content": "RepoMirror Experiment: Headless Loop Analysis  Core Methodology The experiment ran Claude Code in an infinite loop via CLI: This approach was inspired by a technique promoted by Geoff Huntley for continuous agent execution.  Empirical Results Scope: 6 ported codebases across ~29 hours of continuous operation - Commits Generated: Approximately 1,100 commits total across all projects - Infrastructure Cost: ~$800 for inference expenses - Runtime Cost: ~$10.50/hour per Sonnet agent running overnight  Ported Projects 1. better-use (Browser Use: Python â†’ TypeScript) - \"almost fully functional\" 2. ai-sdk-python (Vercel AI SDK: TypeScript â†’ Python) 3. open-dedalus (spec-to-code generation from documentation) 4. Plus 3 additional experimental ports  Configuration & Prompts Minimal Prompt Principle: The most effective prompts were simplest. One team member expanded instructions to 1,500 words with Claude's helpâ€”the agent immediately \"got slower and dumber.\" Reverting to ~103 words restored perfo",
    "url": "/agent-knowledge-base/loops/github-repomirror",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/memory-state/github-beads-viewer",
    "title": "github-beads-viewer",
    "content": "Beads Viewer (bv) > The elegant, keyboard-driven terminal interface for the Beads issue tracker.  Overview  is a high-performance Terminal User Interface (TUI) for browsing and managing tasks in projects that use the Beads issue tracking system. It provides graph analytics capabilities to help agents identify critical path bottlenecks and prioritize work based on dependency analysis.  Why You'd Care - Speed: Browse thousands of issues instantly with zero network latency - Focus: Stay in your terminal with Vim-style navigation (/) - Intelligence: Visualizes projects as dependency graphs, automatically highlighting bottlenecks, cycles, and critical paths - AI-Ready: Provides structured, pre-computed insights for AI coding agents via robot flags  Quick Install  Linux/macOS  Windows (PowerShell) > Note: Windows requires Go 1.21+ (download). For best display, use Windows Terminal with a Nerd Font.  The Core Experience  Fast, Fluid Browsing No web page loads, no heavy clients.  starts instan",
    "url": "/agent-knowledge-base/memory-state/github-beads-viewer",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/memory-state/github-beads",
    "title": "github-beads",
    "content": "Beads Repository Reference  Project Overview Beads is a distributed, git-backed graph issue tracker designed specifically for AI agents. The repository describes it as providing \"persistent, structured memory for coding agents\" by replacing unstructured markdown plans with a dependency-aware graph structure that helps agents maintain context during long-horizon tasks. The project is licensed under MIT and currently has 9.3k stars on GitHub.  Purpose & Core Value Beads addresses a key limitation in agent workflows: maintaining coherent task state across extended interactions. Rather than agents losing context in long conversations, Beads stores issues as JSONL files in a  directory, enabling version control integration and multi-agent coordination.  Quick Start  Installation Methods Three primary installation paths are available: - npm:  - Homebrew:  - Go:   Supported Platforms - Linux (glibc 2.32+) - macOS - Windows  Key Features 1. Git-Backed Storage: Issues stored as JSONL, versioned",
    "url": "/agent-knowledge-base/memory-state/github-beads",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/memory-state/steve-yegge-beads",
    "title": "steve-yegge-beads",
    "content": "Introducing Beads: A Coding Agent Memory System  Access Note Medium article blocked by WebFetch (403 error). Access directly at URL below for full content.  Key Concepts (from source description)  The Dementia Problem Defines the core issue that Beads solves: coding agents lose context and experience \"dementia\" as conversations grow long. Traditional todo lists in markdown don't persist across context compaction.  Context Rot The phenomenon where agent performance degrades as context fills with historical information, reducing available space for active reasoning.  Beads Protocol Git-backed, graph-based memory system that: - Externalizes agent state into structured JSONL files in  directory - Enables version control of agent memory - Supports dependency graphs (not just linear lists) - Persists across context compaction and session boundaries  Dependency Graphs Shift from linear todo lists to graph structures where tasks can: - Depend on other tasks - Block other tasks - Be discovered ",
    "url": "/agent-knowledge-base/memory-state/steve-yegge-beads",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/memory-state/steve-yegge-gastown",
    "title": "steve-yegge-gastown",
    "content": "Gas Town Multi-agent orchestration system for Claude Code with persistent work tracking  Overview Gas Town is a workspace manager that lets you coordinate multiple Claude Code agents working on different tasks. Instead of losing context when agents restart, Gas Town persists work state in git-backed hooks, enabling reliable multi-agent workflows.  What Problem Does This Solve? | Challenge                       | Gas Town Solution                            | | ------------------------------- | -------------------------------------------- | | Agents lose context on restart  | Work persists in git-backed hooks            | | Manual agent coordination       | Built-in mailboxes, identities, and handoffs | | 4-10 agents become chaotic      | Scale comfortably to 20-30 agents            | | Work state lost in agent memory | Work state stored in Beads ledger            |  Architecture  Core Concepts  The Mayor ðŸŽ© Your primary AI coordinator. The Mayor is a Claude Code instance with full cont",
    "url": "/agent-knowledge-base/memory-state/steve-yegge-gastown",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/mobile/petesena-iphone-setup",
    "title": "petesena-iphone-setup",
    "content": "Run Claude Code From Your iPhone - Complete Setup Guide  Access Note Medium article blocked by WebFetch (403 error). Access directly at URL below for full content.  Core Stack Components (from source description)  1. Tailscale - Creates mesh network between iPhone and desktop - Bypasses firewall requirements - Enables secure remote access without port forwarding  2. Termius - SSH client for iPhone - Connects to desktop via Tailscale network - Provides terminal interface on mobile device  3. tmux - Terminal multiplexer on desktop - Keeps Claude Code sessions persistent - Allows attaching/detaching from mobile  Workflow Pattern  tmux.conf Settings The article contains specific tmux.conf settings required to map iPhone touch events to terminal scrolling. These configurations are essential for usable mobile interaction. Critical configurations include: - Touch gesture mappings - Scroll behavior settings - Mobile-optimized key bindings  Use Cases - Monitor long-running agents while away fro",
    "url": "/agent-knowledge-base/mobile/petesena-iphone-setup",
    "category": "agent-knowledge-base"
  },
  {
    "id": "agent-knowledge-base/mobile/sameerhalai-tailscale",
    "title": "sameerhalai-tailscale",
    "content": "Tailscale Networking Summary  Core Functionality Tailscale enables private network connectivity between devices. According to the article, it \"gives you a private network between your desktop and phone without firewall headaches,\" allowing devices to communicate \"as if they were on the same LAN.\"  Firewall Bypass The service eliminates traditional networking obstacles by creating an encrypted overlay network. This removes the need for complex port forwarding or firewall rule configuration.  \"Vibe Coding\" Loop The article describes an interactive development workflow where you can monitor long-running Claude Code sessions remotely. Using tmux combined with Tailscale SSH access, developers can: - Start coding tasks on their desktop - Step away while processes run - Monitor progress from their phone in real-time - Interact bidirectionally (typing commands on either device) This creates a seamless, persistent coding experience across multiple devices without interrupting the original sessi",
    "url": "/agent-knowledge-base/mobile/sameerhalai-tailscale",
    "category": "agent-knowledge-base"
  },
  {
    "id": "references/claudedocs/hooks-how-to",
    "title": "Hooks-how-to",
    "content": "Get started with Claude Code hooks > Learn how to customize and extend Claude Code's behavior by registering shell commands Claude Code hooks are user-defined shell commands that execute at various points in Claude Code's lifecycle. Hooks provide deterministic control over Claude Code's behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them. <Tip>   For reference documentation on hooks, see Hooks reference. </Tip> Example use cases for hooks include:  Notifications: Customize how you get notified when Claude Code is awaiting   your input or permission to run something.  Automatic formatting: Run  on .ts files,  on .go files,   etc. after every file edit.  Logging: Track and count all executed commands for compliance or   debugging.  Feedback: Provide automated feedback when Claude Code produces code that   does not follow your codebase conventions.  Custom permissions: Block modifications to production files or sensitive   directories. By ",
    "url": "/references/claudedocs/hooks-how-to",
    "category": "references"
  },
  {
    "id": "references/claudedocs/hooks",
    "title": "Hooks",
    "content": "Hooks reference > This page provides reference documentation for implementing hooks in Claude Code. <Tip>   For a quickstart guide with examples, see Get started with Claude Code hooks. </Tip>  Configuration Claude Code hooks are configured in your settings files:   - User settings   - Project settings   - Local project settings (not committed)  Managed policy settings <Note>   Enterprise administrators can use  to block user, project, and plugin hooks. See Hook configuration. </Note>  Structure Hooks are organized by matchers, where each matcher can have multiple hooks:  matcher: Pattern to match tool names, case-sensitive (only applicable for   , , and )    Simple strings match exactly:  matches only the Write tool    Supports regex:  or     Use  to match all tools. You can also use empty string () or leave      blank.  hooks: Array of hooks to execute when the pattern matches    : Hook execution type -  for bash commands or  for LLM-based evaluation    : (For ) The bash command to e",
    "url": "/references/claudedocs/hooks",
    "category": "references"
  },
  {
    "id": "references/claudedocs/mcp",
    "title": "MCP",
    "content": "Connect Claude Code to tools via MCP > Learn how to connect Claude Code to your tools with the Model Context Protocol. Claude Code can connect to hundreds of external tools and data sources through the Model Context Protocol (MCP), an open source standard for AI-tool integrations. MCP servers give Claude Code access to your tools, databases, and APIs.  What you can do with MCP With MCP servers connected, you can ask Claude Code to:  Implement features from issue trackers: \"Add the feature described in JIRA issue ENG-4521 and create a PR on GitHub.\"  Analyze monitoring data: \"Check Sentry and Statsig to check the usage of the feature described in ENG-4521.\"  Query databases: \"Find emails of 10 random users who used feature ENG-4521, based on our PostgreSQL database.\"  Integrate designs: \"Update our standard email template based on the new Figma designs that were posted in Slack\"  Automate workflows: \"Create Gmail drafts inviting these 10 users to a feedback session about the new feature",
    "url": "/references/claudedocs/mcp",
    "category": "references"
  },
  {
    "id": "references/claudedocs/memory-management",
    "title": "Memory-management",
    "content": "Manage Claude's memory > Learn how to manage Claude Code's memory across sessions with different memory locations and best practices. Claude Code can remember your preferences across sessions, like style guidelines and common commands in your workflow.  Determine memory type Claude Code offers four memory locations in a hierarchical structure, each serving a different purpose: | Memory Type                | Location                                                                                                                                                        | Purpose                                             | Use Case Examples                                                    | Shared With                     | | -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- | ---------------------",
    "url": "/references/claudedocs/memory-management",
    "category": "references"
  },
  {
    "id": "references/claudedocs/plugin-reference",
    "title": "Plugin-reference",
    "content": "Plugins reference > Complete technical reference for Claude Code plugin system, including schemas, CLI commands, and component specifications. <Tip>   Looking to install plugins? See Discover and install plugins. For creating plugins, see Plugins. For distributing plugins, see Plugin marketplaces. </Tip> This reference provides complete technical specifications for the Claude Code plugin system, including component schemas, CLI commands, and development tools.  Plugin components reference This section documents the five types of components that plugins can provide.  Commands Plugins add custom slash commands that integrate seamlessly with Claude Code's command system. Location:  directory in plugin root File format: Markdown files with frontmatter For complete details on plugin command structure, invocation patterns, and features, see Plugin commands.  Agents Plugins can provide specialized subagents for specific tasks that Claude can invoke automatically when appropriate. Location:  d",
    "url": "/references/claudedocs/plugin-reference",
    "category": "references"
  },
  {
    "id": "references/claudedocs/plugin",
    "title": "Plugin",
    "content": "Create plugins > Create custom plugins to extend Claude Code with slash commands, agents, hooks, Skills, and MCP servers. Plugins let you extend Claude Code with custom functionality that can be shared across projects and teams. This guide covers creating your own plugins with slash commands, agents, Skills, hooks, and MCP servers. Looking to install existing plugins? See Discover and install plugins. For complete technical specifications, see Plugins reference.  When to use plugins vs standalone configuration Claude Code supports two ways to add custom slash commands, agents, and hooks: | Approach                                                    | Slash command names  | Best for                                                                                        | | :---------------------------------------------------------- | :------------------- | :---------------------------------------------------------------------------------------------- | | Standalone ( directory)          ",
    "url": "/references/claudedocs/plugin",
    "category": "references"
  },
  {
    "id": "references/claudedocs/settings",
    "title": "Settings",
    "content": "Claude Code settings > Configure Claude Code with global and project-level settings, and environment variables. Claude Code offers a variety of settings to configure its behavior to meet your needs. You can configure Claude Code by running the  command when using the interactive REPL, which opens a tabbed Settings interface where you can view status information and modify configuration options.  Configuration scopes Claude Code uses a scope system to determine where configurations apply and who they're shared with. Understanding scopes helps you decide how to configure Claude Code for personal use, team collaboration, or enterprise deployment.  Available scopes | Scope       | Location                             | Who it affects                       | Shared with team?      | | :---------- | :----------------------------------- | :----------------------------------- | :--------------------- | | Managed | System-level  | All users on the machine             | Yes (deployed by IT)   | ",
    "url": "/references/claudedocs/settings",
    "category": "references"
  },
  {
    "id": "references/claudedocs/skills-overview",
    "title": "Skills-Overview",
    "content": "Agent Skills > Create, manage, and share Skills to extend Claude's capabilities in Claude Code. This guide shows you how to create, use, and manage Agent Skills in Claude Code. For background on how Skills work across Claude products, see What are Skills?. A Skill is a markdown file that teaches Claude how to do something specific: reviewing PRs using your team's standards, generating commit messages in your preferred format, or querying your company's database schema. When you ask Claude something that matches a Skill's purpose, Claude automatically applies it.  Create your first Skill This example creates a personal Skill that teaches Claude to explain code using visual diagrams and analogies. Unlike Claude's default explanations, this Skill ensures every explanation includes an ASCII diagram and a real-world analogy. <Steps>   <Step title=\"Check available Skills\">     Before creating a Skill, see what Skills Claude already has access to:          Claude will list any Skills currentl",
    "url": "/references/claudedocs/skills-overview",
    "category": "references"
  },
  {
    "id": "references/claudedocs/skills-best-practices",
    "title": "Skills-best-practices",
    "content": "Skill authoring best practices Learn how to write effective Skills that Claude can discover and use successfully. --- Good Skills are concise, well-structured, and tested with real usage. This guide provides practical authoring decisions to help you write Skills that Claude can discover and use effectively. For conceptual background on how Skills work, see the Skills overview.  Core principles  Concise is key The context window is a public good. Your Skill shares the context window with everything else Claude needs to know, including: - The system prompt - Conversation history - Other Skills' metadata - Your actual request Not every token in your Skill has an immediate cost. At startup, only the metadata (name and description) from all Skills is pre-loaded. Claude reads SKILL.md only when the Skill becomes relevant, and reads additional files only as needed. However, being concise in SKILL.md still matters: once Claude loads it, every token competes with conversation history and other ",
    "url": "/references/claudedocs/skills-best-practices",
    "category": "references"
  },
  {
    "id": "references/claudedocs/subagents",
    "title": "subagents",
    "content": "Subagents > Create and use specialized AI subagents in Claude Code for task-specific workflows and improved context management. Custom subagents in Claude Code are specialized AI assistants that can be invoked to handle specific types of tasks. They enable more efficient problem-solving by providing task-specific configurations with customized system prompts, tools and a separate context window.  What are subagents? Subagents are pre-configured AI personalities that Claude Code can delegate tasks to. Each subagent:  Has a specific purpose and expertise area  Uses its own context window separate from the main conversation  Can be configured with specific tools it's allowed to use  Includes a custom system prompt that guides its behavior When Claude Code encounters a task that matches a subagent's expertise, it can delegate that task to the specialized subagent, which works independently and returns results.  Key benefits <CardGroup cols={2}>   <Card title=\"Context preservation\" icon=\"la",
    "url": "/references/claudedocs/subagents",
    "category": "references"
  },
  {
    "id": "references/codexdocs/mcp",
    "title": "MCP",
    "content": "Model Context Protocol Model Context Protocol (MCP) connects models to tools and context. Use it to give Codex access to third-party documentation, or to let it interact with developer tools like your browser or Figma. Codex supports MCP servers in both the CLI and the IDE extension.  Supported MCP features - STDIO servers: Servers that run as a local process (started by a command).   - Environment variables - Streamable HTTP servers: Servers that you access at an address.   - Bearer token authentication   - OAuth authentication (run  for servers that support OAuth)  Connect Codex to an MCP server Codex stores MCP configuration in  alongside other Codex configuration settings. The CLI and the IDE extension share this configuration. Once you configure your MCP servers, you can switch between the two Codex clients without redoing setup. To configure MCP servers, choose one option: 1. Use the CLI: Run  to add and manage servers. 2. Edit : Update  directly.  Configure with the CLI  Add an ",
    "url": "/references/codexdocs/mcp",
    "category": "references"
  },
  {
    "id": "references/codexdocs/memory-management",
    "title": "Memory-management",
    "content": "Custom instructions with AGENTS.md Codex reads  files before doing any work. By layering global guidance with project-specific overrides, you can start each task with consistent expectations, no matter which repository you open.  How Codex discovers guidance Codex builds an instruction chain when it starts (once per run; in the TUI this usually means once per launched session). Discovery follows this precedence order: 1. Global scope: In your Codex home directory (defaults to , unless you set ), Codex reads  if it exists. Otherwise, Codex reads . Codex uses only the first non-empty file at this level. 2. Project scope: Starting at the project root (typically the Git root), Codex walks down to your current working directory. If Codex cannot find a project root, it only checks the current directory. In each directory along the path, it checks for , then , then any fallback names in . Codex includes at most one file per directory. 3. Merge order: Codex concatenates files from the root dow",
    "url": "/references/codexdocs/memory-management",
    "category": "references"
  },
  {
    "id": "references/codexdocs/rules",
    "title": "Rules",
    "content": "Rules Use rules to control which commands Codex can run outside the sandbox. <DocsTip>Rules are experimental and may change.</DocsTip>  Create a rules file 1. Create a  file under  (for example, ). 2. Add a rule. This example prompts before allowing  to run outside the sandbox.     3. Restart Codex. Codex loads every  file under  at startup. When you add a command to the allow list in the TUI, Codex appends a rule to  so future runs can skip the prompt.  Understand rule fields  supports these fields: -  (required): A non-empty list that defines the command prefix to match. Each element is either:   - A literal string (for example, ).   - A union of literals (for example, ) to match alternatives at that argument position. -  (defaults to ): The action to take when the rule matches. Codex applies the most restrictive decision when more than one rule matches ( >  > ).   - : Run the command outside the sandbox without prompting.   - : Prompt before each matching invocation.   - : Block the",
    "url": "/references/codexdocs/rules",
    "category": "references"
  },
  {
    "id": "references/codexdocs/skills-overview",
    "title": "Skills-Overview",
    "content": "Agent Skills Use agent skills to extend Codex with task-specific capabilities. A skill packages instructions, resources, and optional scripts so Codex can follow a workflow reliably. You can share skills across teams or with the community. Skills build on the open agent skills standard. Skills are available in both the Codex CLI and IDE extensions.  Agent skill definition A skill captures a capability expressed through Markdown instructions in a  file. A skill folder can also include scripts, resources, and assets that Codex uses to perform a specific task. <FileTree   class=\"mt-4\"   tree={[     {       name: \"my-skill/\",       open: true,       children: [         {           name: \"SKILL.md\",           comment: \"Required: instructions + metadata\",         },         {           name: \"scripts/\",           comment: \"Optional: executable code\",         },         {           name: \"references/\",           comment: \"Optional: documentation\",         },         {           name: \"assets/",
    "url": "/references/codexdocs/skills-overview",
    "category": "references"
  },
  {
    "id": "references/codexdocs/skills-how-to",
    "title": "Skills-how-to",
    "content": "Create skills Skills let teams capture institutional knowledge and turn it into reusable, shareable workflows. Skills help Codex behave consistently across users, repositories, and sessions, which is especially useful when you want standard conventions and checks applied automatically. A skill is a small bundle consisting of a , a  that explains what it does and when to use it, and an optional body of instructions. Codex injects only the skill's name, description, and file path into the runtime context. The instruction body is never injected unless the skill is explicitly invoked.  Decide when to create a skill Use skills when you want to share behavior across a team, enforce consistent workflows, or encode best practices once and reuse them everywhere. Typical use cases include: - Standardizing code review checklists and conventions - Enforcing security or compliance checks - Automating common analysis tasks - Providing team-specific tooling that Codex can discover automatically Avoid",
    "url": "/references/codexdocs/skills-how-to",
    "category": "references"
  }
]